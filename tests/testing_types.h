#pragma once
#include "okay/detail/abort.h"
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <utility>

enum class StatusCodeA : uint8_t
{
    okay,
    result_released,
    whatever,
    oom,
    bad_access,
};

enum class StatusCodeB : uint8_t
{
    okay = 0,
    result_released,
    nothing = 250,
    more_nothing = 100,
};

struct trivial_t
{
    int whatever;
    const char* nothing;
};

struct moveable_t
{
    int whatever;
    char* nothing;

    moveable_t() noexcept { nothing = new char[150]; }
    ~moveable_t() noexcept { delete[] nothing; };

    // no copying
    moveable_t& operator=(const moveable_t& other) = delete;
    moveable_t(const moveable_t& other) = delete;

    // yay moving
    moveable_t& operator=(moveable_t&& other) noexcept
    {
        nothing = other.nothing;
        whatever = other.whatever;
        other.nothing = nullptr;
        other.whatever = 0;
        return *this;
    }
    moveable_t(moveable_t&& other) noexcept { *this = std::move(other); }
};

struct nonmoveable_t
{
    int whatever;
    const char* nothing;

    nonmoveable_t() { nothing = new char[150]; }
    ~nonmoveable_t() { delete[] nothing; };

    // trivially copyable
    nonmoveable_t& operator=(const nonmoveable_t& other) = default;
    nonmoveable_t(const nonmoveable_t& other) = default;

    // yay moving
    nonmoveable_t& operator=(nonmoveable_t&& other) = delete;
    nonmoveable_t(nonmoveable_t&& other) = delete;
};

class example_iterable_cstyle
{
  public:
    using value_type = uint8_t;
    using default_cursor_type = size_t;

    value_type& operator[](size_t index) OKAYLIB_NOEXCEPT
    {
        if (index >= num_bytes)
            OK_ABORT();
        return bytes[index];
    }

    const value_type& operator[](size_t index) const OKAYLIB_NOEXCEPT
    {
        return (*const_cast<example_iterable_cstyle*>(this))[index];
    }

    example_iterable_cstyle() OKAYLIB_NOEXCEPT
    {
        bytes = static_cast<uint8_t*>(malloc(100));
        std::memset(bytes, 0, 100);
        num_bytes = 100;
    }

    constexpr size_t size() OKAYLIB_NOEXCEPT { return num_bytes; }

  private:
    uint8_t* bytes;
    size_t num_bytes;
};

class example_iterable_with_begin : public example_iterable_cstyle
{
  public:
    inline static constexpr size_t begin_value = 1;
    inline constexpr size_t begin() const { return begin_value; }
};

class example_multiple_cursor_iterable
{
  public:
    using value_type = int;

    inline static constexpr int initial_size_t_cursor_value = 0;
    inline static constexpr size_t iterator_cursor_value = 12394;

    struct iterator
    {
        inline constexpr void operator++() { ++actual; }
        inline constexpr friend bool operator==(const iterator& i,
                                                const iterator& other)
        {
            // TODO: this can be autogenerated by compiler? does that always
            // work, like in c++17?
            return i.actual == other.actual;
        }
        size_t actual = 0;
    };
    using default_cursor_type = iterator;

    // operator [] just returns one number, but its a different number depending
    // on which cursor you use. for testing overloading certain cursors
    inline constexpr value_type& operator[](size_t cursor_default)
    {
        return inner;
    }

    inline constexpr value_type& operator[](const iterator& cursor_default)
    {
        return iterators_inner;
    }

    inline constexpr const value_type& operator[](size_t cursor_default) const
    {
        return inner;
    }

    inline constexpr const value_type&
    operator[](const iterator& cursor_default) const
    {
        return iterators_inner;
    }

    // only allow begin() to be called with size_t, not iterator. iterator
    // begin() is handled by free function
    template <typename C, typename = std::enable_if_t<
                              std::is_same_v<std::decay_t<C>, size_t>>>
    inline constexpr auto begin() const
    {
        return size_t(0);
    }

    int inner = initial_size_t_cursor_value;
    // this never should be accessed by begin() functions
    int iterators_inner = iterator_cursor_value;
};
